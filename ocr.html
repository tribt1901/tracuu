<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <title>üß† OCR + Excel + Nh·∫≠p/ƒê·ªçc C√¢u H·ªèi</title>

  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
  
  <style>
    /* FIX 1: Th√™m padding-top cho menu */
    body { font-family: "Segoe UI", sans-serif; background: #f5f7fb; margin: 0; padding: 20px; padding-top: 70px; }
    .container { background: white; border-radius: 14px; box-shadow: 0 3px 10px rgba(0,0,0,0.1); padding: 25px; max-width: 900px; margin: auto; }
    h1 { text-align: center; color: #0078d7; margin-bottom: 30px; }
    fieldset { border: 2px solid #0078d7; border-radius: 10px; margin-top: 15px; padding: 15px; }
    legend { color: #0078d7; font-weight: bold; padding: 0 10px; }
    input[type="file"], textarea, button, select { margin-top: 10px; font-size: 15px; }
    textarea { width: 100%; height: 90px; border-radius: 8px; border: 1px solid #ccc; padding: 10px; }
    select { padding: 8px; border-radius: 8px; border: 1px solid #ccc; }
    button { background: #0078d7; color: white; border: none; border-radius: 8px; padding: 10px 16px; cursor: pointer; margin-top: 10px; }
    button:hover { background: #005fa3; }
    #output, #answer { background: #f1f1f1; padding: 15px; border-radius: 8px; margin-top: 10px; min-height: 50px; white-space: pre-wrap; }
    #similarityBar { height: 12px; background: #ccc; border-radius: 10px; overflow: hidden; margin-top: 10px; }
    #similarityFill { height: 100%; width: 0%; background: #0078d7; transition: width 0.4s; }
  </style>
</head>
  <body class="bg-light">
<header id="navbar-placeholder"></header>
<body>
  <div class="container">
    <h1>üß† OCR + Excel + Nh·∫≠p/ƒê·ªçc C√¢u H·ªèi</h1>

    <fieldset>
      <legend>1Ô∏è‚É£ Ch·ªçn Ngu·ªìn D·ªØ Li·ªáu ƒê√°p √ÅN:</legend>
      <label><input type="radio" name="dataSource" value="excel" checked> üìÇ File Excel (.xlsx)</label>
      <label><input type="radio" name="dataSource" value="firebase"> ‚òÅÔ∏è CSDL Tra c·ª©u HG</label>
      <label><input type="radio" name="dataSource" value="text"> üìÑ File Text (.txt)</label>

      <div id="firebaseDataSourceArea">
        <select id="subjectSelect">
          <option value="">-- ƒêang t·∫£i danh s√°ch m√¥n... --</option>
        </select>
        <button id="loadFirebaseBtn">‚ö° N·∫°p d·ªØ li·ªáu CSDL</button>
        <p id="firebaseStatus">Ch∆∞a n·∫°p d·ªØ li·ªáu CSDL.</p>
      </div>

      <div id="excelDataSourceArea" style="display:none;">
        <input type="file" id="excelInput" accept=".xlsx,.xls,.csv">
        <p id="excelStatus">Ch∆∞a t·∫£i file Excel.</p>
      </div>

      <div id="textDataSourceArea" style="display:none;">
        <input type="file" id="textInput" accept=".txt">
        <p id="textStatus">Ch∆∞a t·∫£i file Text (.txt).</p>
      </div>
    </fieldset>

    <fieldset>
      <legend>2Ô∏è‚É£ Ch·ªçn c√°ch nh·∫≠p c√¢u h·ªèi:</legend>
      <label><input type="radio" name="inputMode" value="image" checked> üñºÔ∏è ·∫¢nh (OCR)</label>
      <label><input type="radio" name="inputMode" value="text"> ‚úçÔ∏è Nh·∫≠p vƒÉn b·∫£n</label>
      <label><input type="radio" name="inputMode" value="voice"> üé§ ƒê·ªçc b·∫±ng gi·ªçng n√≥i</label>
      <div id="imageInputArea">
        <input type="file" id="imageInput" accept="image/*">
        <p id="imageStatus">Ch∆∞a ch·ªçn ·∫£nh.</p>
      </div>
      <div id="textInputArea" style="display:none;">
        <textarea id="manualText" placeholder="Nh·∫≠p c√¢u h·ªèi t·∫°i ƒë√¢y..."></textarea>
        <button id="searchTextBtn">üîç Tra ƒë√°p √°n</button>
      </div>
      <div id="voiceInputArea" style="display:none;">
        <button id="startVoice">üéôÔ∏è B·∫Øt ƒë·∫ßu n√≥i</button>
        <p id="voiceStatus">Ch∆∞a n√≥i g√¨...</p>
      </div>
    </fieldset>
    
    <fieldset>
      <legend>üìã C√¢u h·ªèi nh·∫≠n ƒë∆∞·ª£c:</legend>
      <div id="output">Ch∆∞a nh·∫≠n d·∫°ng.</div>
    </fieldset>

    <fieldset>
      <legend>üí° ƒê√°p √°n t√¨m ƒë∆∞·ª£c:</legend>
      <div id="answer">Ch∆∞a c√≥ d·ªØ li·ªáu.</div>
      <div id="similarityBar"><div id="similarityFill"></div></div>
      <button id="speakBtn" disabled>üîä ƒê·ªçc ƒë√°p √°n</button>
    </fieldset>
  </div>

  <script>
    let excelData = []; 
    const output = document.getElementById("output");
    const answer = document.getElementById("answer");
    const imageStatus = document.getElementById("imageStatus");
    const excelStatus = document.getElementById("excelStatus");
    const firebaseStatus = document.getElementById("firebaseStatus");
    const textStatus = document.getElementById("textStatus");
    const similarityFill = document.getElementById("similarityFill");

    // --- Kh·ªüi t·∫°o Firebase ---
    // FIX 2: Kh·ªüi t·∫°o FIRESTORE (db)
    const firebaseConfig = {
      apiKey: "AIzaSyAjBMA-atKKvecY8CWeQXZsIQ3yHckZ92M",
      authDomain: "tracuu-d3ee9.firebaseapp.com",
      projectId: "tracuu-d3ee9",
      storageBucket: "tracuu-d3ee9.appspot.com",
      messagingSenderId: "593568604435",
      appId: "1:593568604435:web:9a5145457a8ee734143ae6",
      measurementId: "G-R0M6Y502NP"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore(); 

    // --- Chuy·ªÉn ƒë·ªïi khu v·ª±c nh·∫≠p ---
    document.querySelectorAll('input[name="inputMode"]').forEach(r => {
      r.addEventListener('change', () => {
        document.getElementById("imageInputArea").style.display = r.value === "image" ? "block" : "none";
        document.getElementById("textInputArea").style.display = r.value === "text" ? "block" : "none";
        document.getElementById("voiceInputArea").style.display = r.value === "voice" ? "block" : "none";
      });
    });

    // --- Chuy·ªÉn ƒë·ªïi NGU·ªíN D·ªÆ LI·ªÜU ---
    document.querySelectorAll('input[name="dataSource"]').forEach(r => {
      r.addEventListener('change', () => {
        const val = r.value;
        document.getElementById("firebaseDataSourceArea").style.display = val === "firebase" ? "block" : "none";
        document.getElementById("excelDataSourceArea").style.display = val === "excel" ? "block" : "none";
        document.getElementById("textDataSourceArea").style.display = val === "text" ? "block" : "none";
        
        excelData = [];
        firebaseStatus.textContent = "Ch∆∞a n·∫°p d·ªØ li·ªáu CSDL.";
        excelStatus.textContent = "Ch∆∞a t·∫£i file Excel.";
        textStatus.textContent = "Ch∆∞a t·∫£i file Text (.txt).";
        answer.textContent = "Ch∆∞a c√≥ d·ªØ li·ªáu.";
      });
    });

    // --- T·∫£i danh s√°ch m√¥n h·ªçc t·ª´ FIRESTORE ---
    function loadSubjects() {
      const subjectSelect = document.getElementById("subjectSelect");
      const subjectsRef = db.collection("mon_hoc"); 
      
      subjectsRef.get().then(snapshot => {
        if (!snapshot.empty) {
          subjectSelect.innerHTML = '<option value="">-- Ch·ªçn m√¥n h·ªçc --</option>';
          snapshot.forEach(doc => {
            const subjectKey = doc.id;
            const subjectName = doc.data().ten_mon; // L·∫•y tr∆∞·ªùng ten_mon
            if (subjectName) {
              const option = document.createElement('option');
              option.value = subjectKey; 
              option.textContent = subjectName; 
              subjectSelect.appendChild(option);
            }
          });
        } else {
          subjectSelect.innerHTML = '<option value="">-- Kh√¥ng t√¨m th·∫•y m√¥n h·ªçc --</option>';
        }
      }).catch(error => {
        console.error("L·ªói t·∫£i danh s√°ch m√¥n h·ªçc:", error);
        subjectSelect.innerHTML = '<option value="">-- L·ªói t·∫£i CSDL --</option>';
      });
    }
    // T·∫£i m√¥n h·ªçc v√† ƒë·∫∑t Firebase l√† ngu·ªìn m·∫∑c ƒë·ªãnh khi t·∫£i trang
    document.addEventListener('DOMContentLoaded', () => {
        loadSubjects();
        document.querySelector('input[name="dataSource"][value="firebase"]').checked = true;
        document.getElementById("firebaseDataSourceArea").style.display = "block";
    });


    // --- N√∫t N·∫°p d·ªØ li·ªáu t·ª´ FIRESTORE ---
    document.getElementById("loadFirebaseBtn").addEventListener("click", () => {
      const subjectKey = document.getElementById("subjectSelect").value; 
      if (!subjectKey) {
        firebaseStatus.textContent = "‚ö†Ô∏è Vui l√≤ng ch·ªçn m·ªôt m√¥n h·ªçc.";
        return;
      }
      firebaseStatus.textContent = "üîÑ ƒêang t·∫£i d·ªØ li·ªáu...";
      excelData = []; 
      const questionsRef = db.collection("cau_hoi").where("mon_hoc_id", "==", subjectKey);
      
      questionsRef.get().then(snapshot => {
        if (!snapshot.empty) {
          snapshot.forEach(doc => {
            const data = doc.data();
            const question = data.noi_dung; 
            const correctKey = data.dap_an_dung; 
            const choices = data.lua_chon; 
            let answerText = "Kh√¥ng c√≥ ƒë√°p √°n"; 
            if (choices && correctKey && choices[correctKey]) {
              answerText = choices[correctKey];
            }
            // Th√™m v√†o m·∫£ng v·ªõi key "question" v√† "answer"
            excelData.push({ question: question || "", answer: answerText });
          });
          firebaseStatus.textContent = `‚úÖ ƒê√£ n·∫°p ${excelData.length} c√¢u h·ªèi t·ª´ CSDL.`;
        } else {
          firebaseStatus.textContent = "‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y c√¢u h·ªèi n√†o cho m√¥n n√†y.";
        }
      }).catch(error => {
        console.error("L·ªói t·∫£i c√¢u h·ªèi:", error);
        firebaseStatus.textContent = "‚ùå L·ªói khi t·∫£i d·ªØ li·ªáu CSDL.";
      });
    });


    // --- H√†m gi√∫p chu·∫©n h√≥a header / chu·ªói ---
    function stripDiacritics(str) {
      // Lo·∫°i b·ªè d·∫•u ti·∫øng Vi·ªát
      return str.normalize('NFD').replace(/[\u0300-\u036f]/g, "");
    }
    function normalizeKey(s) {
      return stripDiacritics(String(s || "")).toLowerCase().replace(/[^a-z0-9]/g, "");
    }

    // --- H√†m ph√¢n t√≠ch Text (CSV ho·∫∑c "C√¢u h·ªèi:") ---
    function parseTextData(text) {
        excelData = []; // X√≥a d·ªØ li·ªáu c≈©
        let count = 0;
        // X√≥a BOM n·∫øu c√≥
        text = text.replace(/^\uFEFF/, "");
        const lines = text.split(/\r\n|\n/);

        console.log("parseTextData: t·ªïng d√≤ng =", lines.length);
        // Th·ª≠ t√¨m header trong v√†i d√≤ng ƒë·∫ßu
        const possibleSeparators = [',', '\t', ';'];
        const knownQuestionKeys = ["cauhoi","cauhoi","cauhoi?","noidung","noi_dung","question","questiontext","q","quest"];
        const knownAnswerKeys = ["dapan","dap_an","dapandung","dapandung?","answer","ans","correct","dap_an_dung","dapandung"];

        let found = false;
        let qIndex = -1;
        let aIndex = -1;
        let usedSep = ',';

        for (let i = 0; i < Math.min(6, lines.length) && !found; i++) {
            const line = lines[i].trim();
            if (!line) continue;
            for (const sep of possibleSeparators) {
                // n·∫øu d√≤ng kh√¥ng ch·ª©a ph√¢n c√°ch, b·ªè qua
                if (line.indexOf(sep) === -1) continue;
                const cells = line.split(sep).map(c => c.trim());
                const normCells = cells.map(c => normalizeKey(c));
                // t√¨m index ch·ª©a b·∫•t k·ª≥ kh√≥a 'question' v√† 'answer'
                let qi = -1, ai = -1;
                for (let j = 0; j < normCells.length; j++) {
                  if (knownQuestionKeys.includes(normCells[j]) || normCells[j].includes("cauhoi") || normCells[j].includes("noidung") || normCells[j].includes("question")) {
                    qi = j;
                  }
                  if (knownAnswerKeys.includes(normCells[j]) || normCells[j].includes("dapan") || normCells[j].includes("answer") || normCells[j].includes("correct")) {
                    ai = j;
                  }
                }
                if (qi !== -1 && ai !== -1) {
                  found = true;
                  qIndex = qi;
                  aIndex = ai;
                  usedSep = sep;
                  console.log("parseTextData: t√¨m th·∫•y header ·ªü d√≤ng", i+1, "sep=", sep, "qIndex=", qIndex, "aIndex=", aIndex, "headers=", cells);
                  break;
                }
            }
        }

        // N·∫øu t√¨m th·∫•y header -> parse to√†n b·ªô file v·ªõi separator ƒë√£ ch·ªçn
        if (found) {
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                const parts = line.split(usedSep);
                // b·ªè qua d√≤ng header (so s√°nh by normalized)
                const normLine = parts.map(p => normalizeKey(p)).join('|');
                const headerCheck = (i < 6) && (parts.some(p => normalizeKey(p).includes("cauhoi")) && parts.some(p => normalizeKey(p).includes("dapan")));
                if (headerCheck) continue;
                if (parts.length > Math.max(qIndex, aIndex)) {
                    const question = parts[qIndex].trim().replace(/^"|"$/g, '');
                    const answer = parts[aIndex].trim().replace(/^"|"$/g, '');
                    if (question && answer) {
                        excelData.push({ question, answer });
                        count++;
                    }
                }
            }
        } else {
            // N·∫øu kh√¥ng t√¨m header, th·ª≠ d·∫°ng CSV kh√¥ng header (2 c·ªôt)
            console.log("parseTextData: kh√¥ng t√¨m header, th·ª≠ fallback 2 c·ªôt / d·∫°ng 'C√¢u h·ªèi:'");
            // Th·ª≠ t√°ch b·∫±ng c√°c separator, ∆∞u ti√™n comma -> tab -> semicolon
            let fallbackParsed = false;
            for (const sep of possibleSeparators) {
              let possibleCount = 0;
              for (let i = 0; i < Math.min(10, lines.length); i++) {
                const line = lines[i].trim();
                if (!line) continue;
                const parts = line.split(sep);
                if (parts.length >= 2) possibleCount++;
              }
              if (possibleCount >= 1) {
                // n·∫øu h·∫ßu h·∫øt d√≤ng c√≥ >=2 c·ªôt, ch·ªçn sep v√† xem n·∫øu file kh√¥ng ph·∫£i "C√¢u h·ªèi:" d·∫°ng
                // parse v·ªõi sep v√† l·∫•y 2 c·ªôt ƒë·∫ßu l√†m question/answer
                for (const line of lines) {
                  if (!line.trim()) continue;
                  const parts = line.split(sep);
                  if (parts.length >= 2) {
                    const question = parts[0].trim().replace(/^"|"$/g, '');
                    const answer = parts[1].trim().replace(/^"|"$/g, '');
                    if (question && answer) {
                      excelData.push({ question, answer });
                      count++;
                    }
                  }
                }
                fallbackParsed = true;
                console.log("parseTextData: fallback parsed with sep=", sep, "count=", count);
                break;
              }
            }

            // N·∫øu v·∫´n ch∆∞a c√≥ d·ªØ li·ªáu, th·ª≠ d·∫°ng "C√¢u h·ªèi:" trong to√†n b·ªô text
            if (!fallbackParsed && text.includes("C√¢u h·ªèi")) {
                const parts = text.split("C√¢u h·ªèi:");
                for (let i = 1; i < parts.length; i++) {
                    const chunk = parts[i];
                    const answerSplit = chunk.split(/(\r\n|\n)?ƒê√°p √°n ƒë√∫ng:/);
                    if (answerSplit.length > 1) {
                        let question = answerSplit[0].trim();
                        question = question.replace(/\s+/g, ' ').trim();
                        let ans = answerSplit[answerSplit.length - 1].trim();
                        const firstNewline = ans.indexOf('\n');
                        if (firstNewline !== -1) {
                            ans = ans.substring(0, firstNewline).trim();
                        }
                        question = question.replace(/^[:,\s"]+/, '').replace(/[,"]$/, '').trim();
                        ans = ans.replace(/^[:,\s"]+/, '').replace(/[,"]$/, '').trim();
                        if (question && ans) {
                            excelData.push({ question, answer: ans });
                            count++;
                        }
                    }
                }
            }
        }

        console.log("parseTextData: t·ªïng n·∫°p ƒë∆∞·ª£c =", count);
        return count; // Tr·∫£ v·ªÅ s·ªë c√¢u h·ªèi n·∫°p ƒë∆∞·ª£c
    }

    // --- ƒê·ªçc Excel (XLSX) ---
    document.getElementById("excelInput").addEventListener("change", e => {
      const file = e.target.files[0];
      if (!file) return;
      excelStatus.textContent = "üîÑ ƒêang ƒë·ªçc file Excel...";
      const reader = new FileReader();
      
      reader.onload = evt => {
        try {
          const data = evt.target.result;
          // M·ªôt s·ªë m√°y tr·∫£ ArrayBuffer, m·ªôt s·ªë tr·∫£ Binary string - d√πng XLSX.read with type
          let wb;
          if (data instanceof ArrayBuffer) {
            wb = XLSX.read(data, { type: "array" });
          } else {
            wb = XLSX.read(data, { type: "binary" });
          }
          const sheetName = wb.SheetNames[0];
          const sheet = wb.Sheets[sheetName];
          
          // Chuy·ªÉn ƒë·ªïi to√†n b·ªô sheet th√†nh vƒÉn b·∫£n (CSV)
          const csvText = XLSX.utils.sheet_to_csv(sheet);
          console.log("excelInput: csvText preview:", csvText.slice(0, 1000));
          
          // D√πng h√†m parseTextData ƒë·ªÉ ph√¢n t√≠ch
          const count = parseTextData(csvText);
          
          if (count > 0) {
            excelStatus.textContent = `‚úÖ ƒê√£ n·∫°p ${count} c√¢u h·ªèi t·ª´ Excel.`;
          } else {
            excelStatus.textContent = "‚ùå Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu (h√£y ki·ªÉm tra ƒë·ªãnh d·∫°ng file ho·∫∑c header). M·ªü console ƒë·ªÉ xem chi ti·∫øt.";
            console.warn("parseTextData kh√¥ng n·∫°p ƒë∆∞·ª£c c√¢u h·ªèi. H√£y ki·ªÉm tra CSV ƒë·∫ßu ra ho·∫∑c ƒë·∫∑t header 'C√¢u h·ªèi'/'ƒê√°p √°n'.");
          }
        } catch (err) {
          console.error("L·ªói ƒë·ªçc file Excel:", err);
          excelStatus.textContent = "‚ùå L·ªói khi ƒë·ªçc file Excel. Ki·ªÉm tra console ƒë·ªÉ bi·∫øt chi ti·∫øt.";
        }
      };
      reader.onerror = () => {
         excelStatus.textContent = "‚ùå L·ªói khi ƒë·ªçc file.";
      };
      // ƒë·ªçc d∆∞·ªõi d·∫°ng array buffer ƒë·ªÉ an to√†n
      reader.readAsArrayBuffer(file);
    });

    
    // --- ƒê·ªçc File Text (.txt) ---
    document.getElementById("textInput").addEventListener("change", e => {
        const file = e.target.files[0];
        if (!file) return;
        
        textStatus.textContent = "üîÑ ƒêang ƒë·ªçc file Text...";
        const reader = new FileReader();
        reader.onload = evt => {
            const text = evt.target.result;
            const count = parseTextData(text); // D√πng h√†m th√¥ng minh
            if (count > 0) {
              textStatus.textContent = `‚úÖ ƒê√£ n·∫°p ${count} c√¢u h·ªèi t·ª´ Text.`;
            } else {
              textStatus.textContent = "‚ùå Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu (h√£y ki·ªÉm tra ƒë·ªãnh d·∫°ng file).";
            }
        };
        reader.onerror = () => {
             textStatus.textContent = "‚ùå L·ªói khi ƒë·ªçc file .txt";
        };
        reader.readAsText(file);
    });

    // --- OCR ·∫¢nh ---
    document.getElementById("imageInput").addEventListener("change", async e => {
      const file = e.target.files[0];
      if (!file) return;
      imageStatus.textContent = "üîç ƒêang nh·∫≠n d·∫°ng ·∫£nh...";
      output.textContent = "";
      answer.textContent = "";

      const result = await Tesseract.recognize(file, "vie+eng", {
        logger: m => { if (m.status === "recognizing text") imageStatus.textContent = `üß† OCR: ${Math.round(m.progress * 100)}%`; }
      });

      const text = result.data.text.trim();
      output.textContent = text || "(Kh√¥ng nh·∫≠n ƒë∆∞·ª£c ch·ªØ)";
      imageStatus.textContent = "‚úÖ Ho√†n t·∫•t OCR.";
      if (text) findAnswer(text);
    });

    // --- Tra theo text ---
    document.getElementById("searchTextBtn").addEventListener("click", () => {
      const text = document.getElementById("manualText").value.trim();
      if (!text) return alert("Nh·∫≠p c√¢u h·ªèi tr∆∞·ªõc!");
      output.textContent = text;
      findAnswer(text);
    });

    // --- Voice Recognition ---
    let recognition;
    if ('webkitSpeechRecognition' in window) {
      recognition = new webkitSpeechRecognition();
      recognition.lang = "vi-VN";
      recognition.continuous = false;
      recognition.interimResults = false;
      recognition.onresult = e => {
        const text = e.results[0][0].transcript;
        document.getElementById("voiceStatus").textContent = "‚úÖ Nghe ƒë∆∞·ª£c: " + text;
        output.textContent = text;
        findAnswer(text);
      };
      recognition.onend = () => document.getElementById("voiceStatus").textContent = "‚èπÔ∏è ƒê√£ d·ª´ng ghi √¢m.";
    } else {
      document.getElementById("voiceStatus").textContent = "‚ö†Ô∏è Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ gi·ªçng n√≥i.";
      document.getElementById("startVoice").disabled = true;
    }
    document.getElementById("startVoice").onclick = () => {
      recognition.start();
      document.getElementById("voiceStatus").textContent = "üéôÔ∏è ƒêang nghe...";
    };

    // --- H√†m t√¨m ƒë√°p √°n ---
    function findAnswer(questionText) {
      if (!excelData.length) {
        answer.textContent = "‚ö†Ô∏è Vui l√≤ng n·∫°p d·ªØ li·ªáu (CSDL, Excel, Text) tr∆∞·ªõc.";
        return;
      }
      const normalize = s => s.toLowerCase().replace(/\s+/g, " ").trim();
      const normalizedOcrText = normalize(questionText);

      let best = { score: 0, ans: "Kh√¥ng t√¨m th·∫•y c√¢u tr·∫£ l·ªùi." };

      for (let row of excelData) {
        const q = row.question || ""; 
        if (!q) continue; 
        const normalizedDbQuestion = normalize(q);

        if (normalizedDbQuestion.length > 5 && normalizedOcrText.includes(normalizedDbQuestion)) {
          if (normalizedDbQuestion.length > best.score) {
            best = {
              score: normalizedDbQuestion.length,
              ans: row.answer || ""
            };
          }
        }
      }

      if (best.score > 0) {
        answer.textContent = `‚úÖ Kh·ªõp ‚Üí ${best.ans}`;
        similarityFill.style.width = "100%"; 
        similarityFill.style.background = "#28a745";
      } else {
        answer.textContent = `‚ùå Kh√¥ng t√¨m th·∫•y c√¢u h·ªèi kh·ªõp trong CSDL.`;
        similarityFill.style.width = "0%";
        similarityFill.style.background = "#dc3545";
      }
      document.getElementById("speakBtn").disabled = best.score === 0;
    }

    // --- ƒê·ªçc ƒë√°p √°n ---
    document.getElementById("speakBtn").onclick = () => {
      const utter = new SpeechSynthesisUtterance(answer.textContent);
      utter.lang = "vi-VN";
      speechSynthesis.speak(utter);
    };
  </script>
  
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  
  <script>
  // FIX 1: T·∫£i menu (ƒê∆∞·ªùng d·∫´n t∆∞∆°ng ƒë·ªëi)
  fetch('menu.html') 
    .then(response => response.text())
    .then(data => {
      document.getElementById('navbar-placeholder').innerHTML = data;
    }).catch(err => { console.warn("Kh√¥ng t·∫£i ƒë∆∞·ª£c menu.html:", err); });
  </script>
</body>
</html>
