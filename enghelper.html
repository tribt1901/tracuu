<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Công cụ Học tiếng Anh — Offline Transcription (WASM)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { font-family: Inter, sans-serif; }
    .input-tab-content { display: none; }
    .input-tab-content.active { display: block; }
    .tab-btn.active { border-bottom-color: #3B82F6; color:#3B82F6; font-weight:600 }
    .online-counter-box { text-align:center; padding:8px; background:#f0fdf4; color:#166534; font-weight:500; border-bottom:1px solid #dcfce7; }
    .muted { color:#6b7280; font-size:0.9rem }
  </style>
</head>
<body class="bg-gray-100 min-h-screen">
  <div class="max-w-4xl mx-auto bg-white rounded-2xl shadow-lg overflow-hidden my-6">
    <header class="bg-blue-600 p-6">
      <h1 class="text-2xl text-white font-bold">Công cụ Học tiếng Anh — Offline Transcription</h1>
      <p class="text-blue-100 mt-1">Chạy hoàn toàn trên trình duyệt (WASM + model lưu trong repo). Không gọi API bên ngoài.</p>
    </header>

    <main class="p-6 grid grid-cols-1 lg:grid-cols-2 gap-6">
      <!-- Column 1: Upload + transcript -->
      <div class="space-y-6">
        <div class="rounded-lg border p-4">
          <label class="block font-medium mb-2">1. Chọn file âm thanh (MP3)</label>
          <input id="audio-upload" type="file" accept="audio/*" class="w-full" />
          <audio id="audio-player" controls class="w-full mt-3 hidden"></audio>
          <div id="worker-status" class="mt-2 muted">Worker: chưa khởi tạo</div>
          <div id="transcription-progress" class="mt-2 muted"></div>
        </div>

        <div class="rounded-lg border p-4">
          <h3 class="font-semibold mb-2">Nội dung văn bản (Trích xuất từ MP3)</h3>
          <div id="transcript-display" class="w-full h-48 bg-gray-50 rounded p-3 overflow-y-auto text-sm text-gray-700 border">
            Vui lòng tải MP3 lên. Kết quả trích xuất sẽ xuất hiện ở đây.
          </div>
        </div>
      </div>

      <!-- Column 2: Question + Search -->
      <div class="space-y-6">
        <div class="rounded-lg border p-4">
          <h3 class="font-semibold mb-3">2. Nhập câu hỏi</h3>
          <div class="border-b mb-4">
            <nav class="flex space-x-4" aria-label="Tabs">
              <button class="tab-btn active" data-tab="text">Gõ tay</button>
              <button class="tab-btn" data-tab="image">Quét ảnh</button>
              <button class="tab-btn" data-tab="voice">Giọng nói</button>
            </nav>
          </div>

          <div>
            <div id="tab-text" class="input-tab-content active">
              <textarea id="text-input" class="w-full h-24 p-2 border rounded" placeholder="Nhập câu hỏi..."></textarea>
            </div>
            <div id="tab-image" class="input-tab-content">
              <input id="image-upload" type="file" accept="image/*" />
            </div>
            <div id="tab-voice" class="input-tab-content">
              <button id="voice-input-btn" class="w-full py-3 bg-red-600 text-white rounded">Nhấn để nói</button>
            </div>
          </div>

          <button id="search-btn" class="w-full mt-4 py-3 bg-blue-600 text-white rounded">Tìm kiếm trong nội dung</button>
        </div>

        <div class="rounded-lg border p-4">
          <h3 class="font-semibold mb-2">3. Kết quả</h3>
          <div id="status" class="text-sm italic text-gray-500 mb-2">Sẵn sàng</div>
          <div id="answer-display" class="min-h-[5rem] bg-gray-50 p-3 border text-gray-700">Kết quả sẽ xuất hiện ở đây...</div>
        </div>
      </div>
    </main>
  </div>

  <script>
    // ---------- Config ----------
    // Đặt đường dẫn tới worker và model (local trong repo)
    const WORKER_PATH = './whisper_worker.js'; // worker template (cần sửa để trỏ tới WASM engine)
    // modelUrl: thư mục hoặc file model cần đặt trong repo, ví dụ '/models/ggml-base.en.bin' hoặc '/vosk/model'
    const DEFAULT_MODEL_URL = './models/ggml-small.en.bin'; // ví dụ tên file model (bạn cần thay bằng file thật)
    // ---------- UI elements ----------
    const audioUpload = document.getElementById('audio-upload');
    const audioPlayer = document.getElementById('audio-player');
    const transcriptDisplay = document.getElementById('transcript-display');
    const workerStatusEl = document.getElementById('worker-status');
    const transcriptionProgress = document.getElementById('transcription-progress');
    const textInput = document.getElementById('text-input');
    const searchBtn = document.getElementById('search-btn');
    const statusEl = document.getElementById('status');
    const answerDisplay = document.getElementById('answer-display');
    const tabs = document.querySelectorAll('.tab-btn');
    const tabContents = document.querySelectorAll('.input-tab-content');
    const voiceInputBtn = document.getElementById('voice-input-btn');

    let transcriptContent = '';
    let worker = null;
    let workerReady = false;

    // Khởi tạo worker (tạo 1 lần)
    function initWorker() {
      if (worker) return;
      try {
        worker = new Worker(WORKER_PATH);
      } catch (e) {
        workerStatusEl.textContent = 'Không thể tạo worker: ' + e.message;
        console.error(e);
        return;
      }
      worker.onmessage = (ev) => {
        const m = ev.data;
        if (!m) return;
        if (m.type === 'ready') {
          workerReady = true;
          workerStatusEl.textContent = `Worker: sẵn sàng. Engine: ${m.engine || 'unknown'}.`;
        } else if (m.type === 'log') {
          workerStatusEl.textContent = m.message;
        } else if (m.type === 'progress') {
          transcriptionProgress.textContent = m.message;
        } else if (m.type === 'result') {
          transcriptContent = m.text || '';
          transcriptDisplay.textContent = transcriptContent || 'Không có văn bản trả về.';
          transcriptionProgress.textContent = '';
          statusEl.textContent = 'Đã trích xuất thành công (offline).';
        } else if (m.type === 'error') {
          transcriptionProgress.textContent = '';
          statusEl.textContent = 'Lỗi worker: ' + (m.message || 'unknown');
        } else {
          console.log('Worker message', m);
        }
      };
      worker.onerror = (err) => {
        console.error('Worker error', err);
        workerStatusEl.textContent = 'Worker error: ' + err.message;
      };
      // yêu cầu worker load model (worker implement phải xử lý cmd: 'load-model')
      worker.postMessage({ cmd: 'init', modelUrl: DEFAULT_MODEL_URL });
    }

    // Audio decode -> mono Float32Array (sampleRate from AudioContext)
    async function decodeAudioFileToFloat32(file) {
      const arrayBuffer = await file.arrayBuffer();
      const audioCtx = new (window.OfflineAudioContext || window.webkitOfflineAudioContext)(1, 2, 16000);
      // dùng AudioContext tạm để decode (bảo đảm browser support decodeAudioData)
      const decodeCtx = new (window.AudioContext || window.webkitAudioContext)();
      const audioBuffer = await decodeCtx.decodeAudioData(arrayBuffer);
      // Nếu audioBuffer.sampleRate !== targetRate chúng ta resample bằng OfflineAudioContext
      const targetRate = 16000; // whisper/vosk thường chấp nhận 16000 hoặc 16000-48000 => chọn 16000 để giảm kích thước
      if (audioBuffer.sampleRate === targetRate && audioBuffer.numberOfChannels === 1) {
        // trả về copy để không giữ reference tới AudioBuffer
        return { samples: audioBuffer.getChannelData(0), sampleRate: targetRate };
      }
      // resample
      const lengthInSec = audioBuffer.duration;
      const offlineCtx = new OfflineAudioContext(1, Math.ceil(lengthInSec * targetRate), targetRate);
      // tạo buffer source
      const src = offlineCtx.createBufferSource();
      // mixdown to mono
      const mixBuffer = offlineCtx.createBuffer(1, audioBuffer.length, audioBuffer.sampleRate);
      const out = mixBuffer.getChannelData(0);
      // mix channels
      for (let c = 0; c < audioBuffer.numberOfChannels; c++) {
        const ch = audioBuffer.getChannelData(c);
        for (let i = 0; i < ch.length; i++) out[i] = (out[i] || 0) + ch[i] / audioBuffer.numberOfChannels;
      }
      src.buffer = mixBuffer;
      src.connect(offlineCtx.destination);
      src.start(0);
      const rendered = await offlineCtx.startRendering();
      return { samples: rendered.getChannelData(0), sampleRate: rendered.sampleRate };
    }

    // Convert Float32 [-1,1] to Int16 (for many WASM engines)
    function floatTo16BitPCM(float32Array) {
      const l = float32Array.length;
      const buffer = new Int16Array(l);
      for (let i = 0; i < l; i++) {
        let s = Math.max(-1, Math.min(1, float32Array[i]));
        buffer[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
      }
      return buffer;
    }

    // Khi user chọn audio
    audioUpload.addEventListener('change', async (ev) => {
      const file = ev.target.files && ev.target.files[0];
      if (!file) return;
      initWorker();

      audioPlayer.src = URL.createObjectURL(file);
      audioPlayer.classList.remove('hidden');

      statusEl.textContent = 'Đang giải mã audio và gửi vào engine offline...';
      transcriptionProgress.textContent = 'Chuẩn bị...';
      transcriptDisplay.textContent = 'Đang trích xuất... (cần model WASM + dữ liệu model trong repo).';

      try {
        const { samples, sampleRate } = await decodeAudioFileToFloat32(file);
        transcriptionProgress.textContent = 'Đã decode audio. sampleRate=' + sampleRate + ', length=' + samples.length;
        // convert to Int16 (copy)
        const int16 = floatTo16BitPCM(samples);
        transcriptionProgress.textContent = 'Chuẩn bị gửi dữ liệu đến worker...';

        // Gửi chuyển nhượng mảng (transfer) để giảm copy
        worker.postMessage({
          cmd: 'transcribe',
          audioBuffer: int16.buffer,
          sampleRate: sampleRate
        }, [int16.buffer]);

        statusEl.textContent = 'Đã gửi audio vào worker, chờ kết quả...';
      } catch (err) {
        console.error(err);
        statusEl.textContent = 'Lỗi khi giải mã/chuẩn bị audio: ' + err.message;
        transcriptionProgress.textContent = '';
      }
    });

    // Tab switching (giữ giống UI trước)
    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        const t = tab.getAttribute('data-tab');
        tabs.forEach(x => x.classList.remove('active'));
        tabContents.forEach(c => c.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById('tab-' + t).classList.add('active');
      });
    });

    // Search trong transcript
    searchBtn.addEventListener('click', () => {
      const q = (textInput.value || '').trim().toLowerCase();
      if (!q) { statusEl.textContent = 'Vui lòng nhập câu hỏi.'; return; }
      if (!transcriptContent) { statusEl.textContent = 'Chưa có transcript. Hãy tải MP3 và chờ trích xuất.'; return; }
      statusEl.textContent = 'Đang tìm...';
      const low = transcriptContent.toLowerCase();
      const idx = low.indexOf(q);
      if (idx === -1) {
        statusEl.textContent = 'Không tìm thấy.';
        answerDisplay.textContent = 'Không tìm thấy trong transcript.';
        return;
      }
      const before = Math.max(0, idx - 80);
      const after = Math.min(transcriptContent.length, idx + q.length + 220);
      const snippet = transcriptContent.substring(before, after);
      // highlight
      const highlighted = snippet.replace(new RegExp(q.replace(/[.*+?^${}()|[\]\\]/g,'\\$&'), 'ig'), (m) => `<mark style="background:yellow">${m}</mark>`);
      answerDisplay.innerHTML = highlighted;
      statusEl.textContent = 'Đã tìm thấy (đã hiển thị đoạn văn).';
    });

    // Voice recognition bằng Web Speech (vẫn client-side, không cần WASM model)
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (SpeechRecognition) {
      const recog = new SpeechRecognition();
      recog.lang = 'en-US';
      recog.interimResults = false;
      voiceInputBtn.addEventListener('click', () => {
        statusEl.textContent = 'Đang nghe qua microphone (Web Speech API).';
        recog.start();
      });
      recog.onresult = (e) => {
        textInput.value = e.results[0][0].transcript;
        statusEl.textContent = 'Đã nhận thoại (Web Speech).';
      };
      recog.onerror = (e) => {
        statusEl.textContent = 'Lỗi Web Speech: ' + e.error;
      };
    } else {
      voiceInputBtn.disabled = true;
      voiceInputBtn.textContent = 'Trình duyệt không hỗ trợ Web Speech API';
    }

    // Khởi tạo worker ngay khi load (để tải model sẵn)
    initWorker();

    // Nhận lệnh từ worker: nếu cần bạn có thể expose hàm để worker gửi transcript về
    // Worker template sẽ gửi { type: 'result', text: '...' } khi hoàn tất
  </script>
</body>
</html>
